"""
modules/core/model_manager/api.py
MIGRATED TO DECORATOR PATTERN - Core model manager module for the Modular Framework

This module provides model management and coordination for the entire framework.
It's now the seventh and final core module to demonstrate the centralized registration decorator pattern.

Updated: August 9, 2025 - Migrated to decorator pattern
Original: Generated by Module Scaffolder V2
"""

import logging
from typing import Dict, List, Any, Union, Optional

# Import complete decorator system for centralized registration
from core.decorators import (
    register_service,
    ServiceMethod,
    ServiceParam,
    ServiceReturn,
    ServiceExample,
    enforce_data_integrity,
    module_health_check,
    graceful_shutdown,
    force_shutdown,
    inject_dependencies,
    initialization_sequence,
    phase2_operations,
    auto_service_creation,
    register_api_endpoints
)
from core.module_base import DataIntegrityModule

from core.error_utils import error_message, create_error_response

from .services import ModelManagerService
# Import new Pydantic settings model for settings integration
from .settings import ModelManagerSettings

# NEW DECORATOR-BASED MODULE CLASS (centralized registration)

# v3.0.0 Complete Decorator-Based Registration (eliminates all manual patterns)
@register_service("core.model_manager.service", methods=[
    ServiceMethod(
        name="initialize",
        description="Initialize model manager service with settings and device management",
        params=[
            ServiceParam("settings", Dict[str, Any], required=False, description="Optional pre-loaded settings dictionary")
        ],
        returns=ServiceReturn("Result", "Result indicating initialization success"),
        examples=[
            ServiceExample("initialize()", "Result.success(data={'initialized': True})"),
            ServiceExample("initialize(settings={'worker_pool_size': 2})", "Result.success(...)")
        ],
        tags=["phase2", "initialization"]
    ),
    ServiceMethod(
        name="generate_embeddings",
        description="Generate vector embeddings for text using specified model",
        params=[
            ServiceParam("texts", Union[str, List[str]], required=True, description="Text or list of texts to embed"),
            ServiceParam("model_id", str, required=False, default="embedding", description="Model ID for embedding generation")
        ],
        returns=ServiceReturn("Result", "Result with generated embeddings"),
        examples=[
            ServiceExample("generate_embeddings('Hello world')", "Result.success(data={'embeddings': [[0.1, 0.2, ...]]})"),
            ServiceExample("generate_embeddings(['text1', 'text2'], 'custom_model')", "Result.success(...)")
        ],
        tags=["embeddings", "ml", "text-processing"]
    ),
    ServiceMethod(
        name="get_text_generation_model",
        description="Get or load a text generation model for inference",
        params=[
            ServiceParam("model_id", str, required=False, default="t5_summarizer", description="Model ID for text generation")
        ],
        returns=ServiceReturn("Result", "Result with model instance or loading status"),
        examples=[
            ServiceExample("get_text_generation_model()", "Result.success(data={'model': <model_instance>})"),
            ServiceExample("get_text_generation_model('gpt_model')", "Result.success(...)")
        ],
        tags=["text-generation", "ml", "model-loading"]
    ),
    ServiceMethod(
        name="get_embedding_model", 
        description="Get or load an embedding model for vector generation",
        params=[
            ServiceParam("model_id", str, required=False, default="embedding", description="Model ID for embeddings")
        ],
        returns=ServiceReturn("Result", "Result with embedding model instance"),
        examples=[
            ServiceExample("get_embedding_model()", "Result.success(data={'model': <embedding_model>})"),
            ServiceExample("get_embedding_model('sentence_transformer')", "Result.success(...)")
        ],
        tags=["embeddings", "ml", "model-loading"]
    ),
    ServiceMethod(
        name="get_model_status",
        description="Get status information for all loaded models",
        params=[],
        returns=ServiceReturn("Result", "Result with model status information"),
        examples=[
            ServiceExample("get_model_status()", "Result.success(data={'loaded_models': ['model1', 'model2'], 'memory_usage': {...}})"),
        ],
        tags=["status", "monitoring", "models"]
    ),
    ServiceMethod(
        name="get_worker_pool_status",
        description="Get status of the model worker pool",
        params=[],
        returns=ServiceReturn("Result", "Result with worker pool status"),
        examples=[
            ServiceExample("get_worker_pool_status()", "Result.success(data={'active_workers': 2, 'pending_tasks': 0})"),
        ],
        tags=["status", "workers", "monitoring"]
    ),
    ServiceMethod(
        name="scale_workers",
        description="Scale the worker pool to target number of workers",
        params=[
            ServiceParam("target_count", int, required=True, description="Target number of workers")
        ],
        returns=ServiceReturn("Result", "Result indicating scaling operation success"),
        examples=[
            ServiceExample("scale_workers(4)", "Result.success(data={'scaled_to': 4, 'previous_count': 2})"),
        ],
        tags=["scaling", "workers", "management"]
    ),
    ServiceMethod(
        name="release_model",
        description="Release a loaded model to free memory",
        params=[
            ServiceParam("model_id", str, required=True, description="Model ID to release")
        ],
        returns=ServiceReturn("Result", "Result indicating release operation success"),
        examples=[
            ServiceExample("release_model('large_model')", "Result.success(data={'released': True, 'memory_freed': '2GB'})"),
        ],
        tags=["memory-management", "models", "cleanup"]
    )
], priority=40)
@inject_dependencies("app_context")
@auto_service_creation(service_class="ModelManagerService")
@initialization_sequence("setup_infrastructure", "create_service", "register_settings", phase="phase1")
@phase2_operations("initialize_service", dependencies=["core.settings.phase2_auto"], priority=40)
@enforce_data_integrity(strict_mode=True, anti_mock=True)
@module_health_check(interval=300)
@register_api_endpoints(router_name="router")
@graceful_shutdown(method="cleanup_resources", timeout=30, priority=40)
@force_shutdown(method="force_cleanup", timeout=10)
class ModelManagerModule(DataIntegrityModule):
    """
    Core model manager module using decorator pattern.
    
    This module provides:
    - Model lifecycle management
    - Model registration coordination
    - Model validation and integrity
    - Model dependency resolution
    - Database model coordination
    
    Foundation module with priority initialization (priority=40).
    All registration via decorators with NO manual code!
    
    centralized registration benefits:
    - Zero boilerplate registration code
    - Impossible to forget critical registration steps
    - Consistent with all other decorator-based modules
    - Foundation module patterns preserved
    """
    
    MODULE_ID = "core.model_manager"
    MODULE_NAME = "Model Manager Module"
    MODULE_DESCRIPTION = "Core model management and coordination"
    MODULE_VERSION = "1.0.0"
    MODULE_AUTHOR = "Modular Framework"
    MODULE_DEPENDENCIES = ["core.settings"]  # Requires settings for configuration
    MODULE_ENTRY_POINT = "api.py"
    
    def __init__(self):
        """Framework-compatible constructor - dependency injection via decorators."""
        super().__init__()
        self.app_context = None  # Will be injected by framework during processing
        self.service_instance = None
        self.logger.info(f"{self.MODULE_ID} created with complete decorator system")
    
    def setup_infrastructure(self):
        """Framework calls automatically in Phase 1 - Set up basic infrastructure."""
        self.logger.info(f"{self.MODULE_ID}: Setting up infrastructure")
        
        # Note: Settings service not available in Phase 1 by design
        # Dependency resolution happens in Phase 2 via @phase2_operations decorator
        
        self.logger.info(f"{self.MODULE_ID}: Infrastructure setup complete")
    
    def create_service(self):
        """Framework calls automatically in Phase 1 - Create service instance."""
        self.logger.info(f"{self.MODULE_ID}: Creating service instance")
        
        # Service automatically created by @auto_service_creation - no manual creation needed!
        if not self.service_instance:
            self.logger.error(f"{self.MODULE_ID}: service_instance should have been created by @auto_service_creation")
            raise RuntimeError("Auto service creation failed - service_instance not available")
        
        self.logger.info(f"{self.MODULE_ID}: Service instance created")
    
    def register_settings(self):
        """Framework calls automatically in Phase 1 - Register Pydantic settings model."""
        self.logger.info(f"{self.MODULE_ID}: Registering Pydantic settings model")
        
        try:
            # Register Pydantic settings model with app_context (Phase 1)
            self.app_context.register_pydantic_model(self.MODULE_ID, ModelManagerSettings)
            self.logger.info(f"{self.MODULE_ID}: Pydantic settings model registered with framework")
        except Exception as e:
            self.logger.error(f"{self.MODULE_ID}: Error registering settings: {str(e)}")
        
        self.logger.info(f"{self.MODULE_ID}: Phase 1 complete")
    
    async def initialize_service(self):
        """Framework calls automatically in Phase 2 - Initialize service with typed Pydantic settings.
        app_context available via self.app_context (injected by decorators)."""
        self.logger.info(f"{self.MODULE_ID}: Phase 2 - Initializing service with typed settings")
        
        try:
            if self.service_instance:
                # Get typed Pydantic settings from settings service
                settings_service = self.app_context.get_service("core.settings.service")
                if settings_service:
                    result = await settings_service.get_typed_settings(
                        module_id=self.MODULE_ID,
                        model_class=ModelManagerSettings,
                        database_name="settings"  # Explicit database selection
                    )
                    
                    if result.success:
                        typed_settings = result.data  # This is a validated ModelManagerSettings instance
                        
                        # Initialize service with typed settings
                        if hasattr(self.service_instance, 'initialize'):
                            await self.service_instance.initialize(typed_settings)
                            self.logger.info(f"{self.MODULE_ID}: Service initialized with typed Pydantic settings")
                        else:
                            self.logger.warning(f"{self.MODULE_ID}: Service has no initialize() method")
                    else:
                        self.logger.error(f"{self.MODULE_ID}: Failed to get typed settings: {result.message}")
                        # Fall back to service initialization without settings
                        if hasattr(self.service_instance, 'initialize'):
                            await self.service_instance.initialize()
                else:
                    self.logger.error(f"{self.MODULE_ID}: Settings service not available in Phase 2")
            else:
                self.logger.error(f"{self.MODULE_ID}: Service not created in Phase 1")
                
        except Exception as e:
            self.logger.error(f"{self.MODULE_ID}: Exception initializing service: {str(e)}")
        
        self.logger.info(f"{self.MODULE_ID}: Phase 2 initialization complete")
    
    async def health_check(self) -> bool:
        """Health check function (registered automatically via decorator)."""
        try:
            # Check if service is available and initialized
            if not self.service_instance:
                return False
                
            # Check if model manager service is operational
            # This could be enhanced to check model registration status
            
            self.logger.debug(f"{self.MODULE_ID} health check passed - model manager operational")
            return True
            
        except Exception as e:
            self.logger.error(f"{self.MODULE_ID} health check failed: {str(e)}")
            return False
    
    async def cleanup_resources(self):
        """Framework calls automatically during graceful shutdown - only cleanup logic."""
        # Only cleanup logic here - framework handles all logging automatically!
        if self.service_instance and hasattr(self.service_instance, 'shutdown'):
            if hasattr(self.service_instance.shutdown, '__await__'):
                await self.service_instance.shutdown()
            else:
                self.service_instance.shutdown()
    
    def force_cleanup(self):
        """Framework calls automatically during force shutdown - only cleanup logic."""
        # Only cleanup logic here - framework handles all logging automatically!
        if self.service_instance and hasattr(self.service_instance, 'force_close'):
            self.service_instance.force_close()

# FASTAPI ROUTES

from fastapi import APIRouter, HTTPException, Depends, Request
from fastapi.responses import JSONResponse

from .api_schemas import (
    ReleaseModelRequest,
    ModelStatusResponse,
    ServiceStatusResponse,
    ModelReleaseResponse,
    ErrorResponse
)

# Create router for this module
router = APIRouter(tags=["model-manager"])

def get_model_service():
    """Dependency to get model manager service."""
    async def _get_model_service(request: Request):
        service = request.app.state.app_context.get_service("core.model_manager.service")
        if not service:
            raise HTTPException(status_code=503, detail="Model manager service not available")
        return service
    return _get_model_service


@router.get("/status", response_model=ServiceStatusResponse)
async def get_service_status(service = Depends(get_model_service())):
    """
    Get comprehensive model manager service status.
    
    Args:
        service: Model manager service dependency
    
    Returns:
        ServiceStatusResponse with initialization status, loaded models count, and cache size
    """
    try:
        # Get basic service status (includes worker pool status)
        status_result = await service.get_service_status()
        
        if not status_result.success:
            raise HTTPException(
                status_code=500,
                detail=ErrorResponse(
                    code=status_result.error.get("code", "STATUS_ERROR"),
                    message=f"Failed to get service status: {status_result.error.get('message', 'Unknown error')}"
                ).dict()
            )
        
        status_data = status_result.data
        
        return ServiceStatusResponse(
            module_id="core.model_manager",
            initialized=status_data.get("initialized", True),
            config_loaded=True,
            loaded_models=status_data.get("total_loaded_models", 0),
            cache_size=status_data.get("embedding_cache", {}).get("size", 0)
        )
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=ErrorResponse(
                code="STATUS_ERROR",
                message=f"Failed to get service status: {str(e)}"
            ).model_dump()
        )

@router.get("/models", response_model=ModelStatusResponse)
async def get_model_status(service = Depends(get_model_service())):
    """
    Get detailed status information for all loaded models.
    
    Args:
        service: Model manager service dependency
    
    Returns:
        ModelStatusResponse with loaded model count, cache size, and detailed model information
    """
    try:
        result = await service.get_service_status()
        
        if not result.success:
            raise HTTPException(
                status_code=500,
                detail=ErrorResponse(
                    code=result.code or "MODEL_STATUS_FAILED",
                    message=result.message or "Failed to get model status"
                ).model_dump()
            )
        
        status_data = result.data
        loaded_models_data = status_data.get("loaded_models", {})
        
        # Transform loaded_models data to ModelInfo format
        models = {}
        for model_id, model_details in loaded_models_data.items():
            # Determine device from worker info if available
            device = model_details.get("device", "unknown")
            if device == "unknown" and model_details.get("source") == "worker_pool":
                device = model_details.get("device", "unknown")
            
            # Set dimension for embedding models
            dimension = None
            if model_id == "embedding":  # Known embedding model
                dimension = 1024  # mixedbread model dimension
            
            models[model_id] = {
                "model_id": model_id,
                "model_type": "embedding" if model_id == "embedding" else "unknown",
                "name": model_id,
                "dimension": dimension,
                "device": device,
                "references": model_details.get("reference_count", 0),
                "last_accessed": model_details.get("last_accessed", 0),
                "created_at": model_details.get("created_at", 0)
            }
        
        return ModelStatusResponse(
            loaded_models=status_data.get("total_loaded_models", 0),
            cache_size=status_data.get("embedding_cache", {}).get("size", 0),
            models=models
        )
            
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=ErrorResponse(
                code="INTERNAL_ERROR",
                message=f"Internal server error: {str(e)}"
            ).model_dump()
        )

@router.delete("/models/{model_id}", response_model=ModelReleaseResponse)
async def release_model(
    model_id: str,
    service = Depends(get_model_service())
):
    """
    Release a loaded model to free memory resources.
    
    Args:
        model_id: Path parameter - ID of the model to release
        service: Model manager service dependency
    
    Returns:
        ModelReleaseResponse with model ID and remaining reference count
    """
    try:
        result = await service.release_model(model_id)
        
        if result.success:
            return ModelReleaseResponse(
                model_id=model_id,
                remaining_references=result.data.get("remaining_references", 0)
            )
        else:
            raise HTTPException(
                status_code=400,
                detail=ErrorResponse(
                    code=result.code or "RELEASE_FAILED",
                    message=result.message or f"Failed to release model {model_id}"
                ).model_dump()
            )
            
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=ErrorResponse(
                code="INTERNAL_ERROR",
                message=f"Internal server error: {str(e)}"
            ).model_dump()
        )

@router.get("/workers", response_model=dict)
async def get_worker_status(service = Depends(get_model_service())):
    """
    Get current status of the model worker pool.
    
    Args:
        service: Model manager service dependency
    
    Returns:
        Dictionary with worker pool status including active workers and pending tasks
    """
    try:
        result = await service.get_worker_pool_status()
        
        if result.success:
            return result.data
        else:
            raise HTTPException(
                status_code=500,
                detail=ErrorResponse(
                    code=result.code or "WORKER_STATUS_FAILED",
                    message=result.message or "Failed to get worker pool status"
                ).model_dump()
            )
            
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=ErrorResponse(
                code="INTERNAL_ERROR",
                message=f"Internal server error: {str(e)}"
            ).model_dump()
        )


# MODULE CONSTANTS

# Module identity
MODULE_ID = "core.model_manager"
MODULE_VERSION = "1.0.0"
MODULE_DESCRIPTION = "Core model management and coordination"

# ROUTE REGISTRATION

def register_routes(app_router):
    """Register module routes with the main FastAPI app."""
    app_router.include_router(router, prefix="/model-manager")
    return True