"""
modules/core/settings/api.py
Settings Module - FULL decorator-based module.

Generated by Module Scaffolder V3 - FULL Decorator Architecture
"""

from typing import Dict, Any, Type
from pydantic import BaseModel

from core.logging import get_framework_logger
from core.error_utils import error_message, Result
from core.decorators import (
    register_service,
    ServiceMethod,
    ServiceParam,
    ServiceReturn,
    ServiceExample,
    auto_service_creation,
    phase2_operations,
    enforce_data_integrity,
    graceful_shutdown,
    force_shutdown,
    require_services,
    register_api_endpoints,
    inject_dependencies,
)
from core.module_base import DataIntegrityModule

from .services import SettingsService

# Module metadata
MODULE_ID = "core.settings"
MODULE_VERSION = "1.0.0"
MODULE_DESCRIPTION = "Settings - Pydantic-first settings with memory optimization"
MODULE_DEPENDENCIES = ['core.database']

logger = get_framework_logger(MODULE_ID)

# FULL Decorator-Based Module (v3.0.0 Complete Architecture)
@inject_dependencies('app_context')
@register_service("core.settings.service", methods=[
    ServiceMethod(
        name="register_pydantic_model",
        description="Register a Pydantic model for a module's settings",
        params=[
            ServiceParam("module_id", str, required=True, 
                        description="Module identifier (e.g., 'core.model_manager')"),
            ServiceParam("model_class", Type[BaseModel], required=True,
                        description="Pydantic model class with defaults and validation")
        ],
        returns=ServiceReturn(Result, "Result with registration information"),
        examples=[
            ServiceExample(
                "register_pydantic_model('core.my_module', MyModuleSettings)",
                "Result.success(data={'module_id': 'core.my_module', 'settings_count': 5})"
            )
        ],
        tags=["phase1", "registration"]
    ),
    ServiceMethod(
        name="create_baseline",
        description="Create settings baseline from defaults and environment variables",
        params=[],
        returns=ServiceReturn(Result, "Result with baseline creation information"),
        examples=[
            ServiceExample(
                "create_baseline()",
                "Result.success(data={'modules_processed': 5, 'env_vars_applied': 3})"
            )
        ],
        tags=["phase2", "initialization"]
    ),
    ServiceMethod(
        name="get_typed_settings",
        description="Get type-safe settings for a module",
        params=[
            ServiceParam("module_id", str, required=True,
                        description="Module identifier"),
            ServiceParam("model_class", Type[BaseModel], required=True,
                        description="Pydantic model class for validation")
        ],
        returns=ServiceReturn(BaseModel, "Typed settings instance"),
        examples=[
            ServiceExample(
                "get_typed_settings('core.my_module', MyModuleSettings)",
                "MyModuleSettings(setting1='value1', setting2=42)"
            )
        ],
        tags=["runtime", "typed-access"]
    ),
    ServiceMethod(
        name="set_user_preference",
        description="Set a user preference for a module setting",
        params=[
            ServiceParam("module_id", str, required=True,
                        description="Module identifier"),
            ServiceParam("setting_key", str, required=True,
                        description="Setting key to modify"),
            ServiceParam("value", Any, required=True,
                        description="New value for the setting"),
            ServiceParam("database_name", str, required=True,
                        description="Database name for user preferences")
        ],
        returns=ServiceReturn(Result, "Result with preference update information"),
        examples=[
            ServiceExample(
                "set_user_preference('core.my_module', 'debug_mode', True, 'settings')",
                "Result.success(data={'updated': True, 'previous_value': False})"
            )
        ],
        tags=["runtime", "user-preferences"]
    ),
    ServiceMethod(
        name="clear_user_preference",
        description="Clear a user preference, reverting to baseline value",
        params=[
            ServiceParam("module_id", str, required=True,
                        description="Module identifier"),
            ServiceParam("setting_key", str, required=True,
                        description="Setting key to clear"),
            ServiceParam("database_name", str, required=True,
                        description="Database name for user preferences")
        ],
        returns=ServiceReturn(Result, "Result with preference clear information"),
        examples=[
            ServiceExample(
                "clear_user_preference('core.my_module', 'debug_mode', 'settings')",
                "Result.success(data={'cleared': True, 'reverted_to': False})"
            )
        ],
        tags=["runtime", "user-preferences"]
    )
], priority=5)  # High priority - needed for Phase 1 registrations
@require_services(["core.database.service", "core.database.crud_service"])
@phase2_operations("initialize_with_dependencies", priority=200)
@auto_service_creation(service_class="SettingsService")
@register_api_endpoints(router_name="router")
@enforce_data_integrity(strict_mode=True, anti_mock=True)
# Note: Decorator timeouts will be configurable via environment variables CORE_SETTINGS_GRACEFUL_SHUTDOWN_TIMEOUT=30
@graceful_shutdown(method="cleanup_resources", timeout=30)
@force_shutdown(method="force_cleanup", timeout=5)
class SettingsModule(DataIntegrityModule):
    """
    Settings Module - FULL Decorator Architecture
    
    Generated with complete decorator system for clean, maintainable code.
    """
    
    # Required module constants
    MODULE_ID = "core.settings"
    MODULE_VERSION = "1.0.0"
    MODULE_DESCRIPTION = "Settings - Pydantic-first settings with memory optimization"
    
    def __init__(self):
        """FULL decorator initialization - NO manual dependencies."""
        super().__init__()
        self.service_instance = None
        self.initialized = False
        
        logger.info(f"{self.MODULE_ID} created with FULL decorator system")
    
    async def initialize_with_dependencies(self):
        """Phase 2: Initialize with guaranteed service access."""
        logger.info(f"{self.MODULE_ID}: Phase 2 - Initializing with dependencies")
        
        try:
            # Services guaranteed available via @require_services decorator
            database_service = self.get_required_service("core.database.service")
            crud_service = self.get_required_service("core.database.crud_service")
            
            # Initialize service with dependencies
            if self.service_instance:
                success = await self.service_instance.initialize(
                    database_service=database_service,
                    crud_service=crud_service
                )
                
                if success:
                    # Parse environment variables and create baseline
                    baseline_result = await self.service_instance.create_baseline()
                    if baseline_result.success:
                        self.initialized = True
                    logger.info(f"{self.MODULE_ID}: Phase 2 initialization complete")
                    return True
                else:
                    logger.error(f"{self.MODULE_ID}: Service initialization failed")
                    return False
            else:
                logger.error(f"{self.MODULE_ID}: Service instance not created")
                return False
                
        except Exception as e:
            logger.error(error_message(
                module_id=self.MODULE_ID,
                error_type="PHASE2_INIT_ERROR",
                details=f"Phase 2 initialization failed: {str(e)}",
                location="initialize_with_dependencies()"
            ))
            return False
    
    def get_service(self):
        """Get the service instance."""
        return self.service_instance
    
    async def cleanup_resources(self):
        """Graceful shutdown - cleanup only."""
        if self.service_instance and hasattr(self.service_instance, 'cleanup_resources'):
            await self.service_instance.cleanup_resources()
    
    def force_cleanup(self):
        """Force shutdown - cleanup only."""
        if self.service_instance and hasattr(self.service_instance, 'force_cleanup'):
            self.service_instance.force_cleanup()

# FastAPI Routes
from fastapi import APIRouter, HTTPException, Depends, Request
from core.error_utils import create_error_response
from .api_schemas import (
    SetUserPreferenceRequest,
    ModuleSettingsResponse,
    AllSettingsResponse,
    UserPreferenceResponse,
    StatusResponse,
    InfoResponse
)

router = APIRouter(tags=["settings"])

def get_module_service():
    """Dependency to get the module service."""
    async def _get_module_service(request: Request):
        return request.app.state.app_context.get_service("core.settings.service")
    return _get_module_service

@router.get("/status", response_model=StatusResponse)
async def get_status(service = Depends(get_module_service())):
    """Get module status - Essential for UI service detection."""
    try:
        if not service:
            raise HTTPException(
                status_code=503,
                detail=create_error_response(
                    module_id=MODULE_ID,
                    code="SERVICE_UNAVAILABLE",
                    message="Service is not available"
                )
            )
        
        return {"status": "active", "module": "settings"}
        
    except HTTPException:
        raise
        
    except Exception as e:
        logger.error(error_message(
            module_id=MODULE_ID,
            error_type="UNEXPECTED_ERROR",
            details=f"Unexpected error in get_status: {str(e)}",
            location="get_status()"
        ))
        
        raise HTTPException(
            status_code=500,
            detail=create_error_response(
                module_id=MODULE_ID,
                code="INTERNAL_ERROR",
                message="An unexpected error occurred"
            )
        )

@router.get("/info", response_model=InfoResponse)
async def get_info():
    """Get module information."""
    return {
        "name": "settings",
        "version": MODULE_VERSION,
        "description": MODULE_DESCRIPTION
    }

# Settings V2 API Endpoints
from .api_schemas import SetUserPreferenceRequest

@router.get("/settings/{module_id}", response_model=ModuleSettingsResponse)
async def get_module_settings(module_id: str, service = Depends(get_module_service())):
    """Get effective settings for a module (baseline + user preferences)."""
    try:
        if not service or not service.initialized:
            raise HTTPException(status_code=503, detail=create_error_response(
                module_id=MODULE_ID, code="SERVICE_UNAVAILABLE", 
                message="Settings V2 service not available"))
        
        # Get baseline settings for the module
        baseline = service.resolved_baseline.get(module_id, {})
        
        # Get user preferences from configured database
        db_name = service.get_configured_database_name()
        user_prefs = await service._get_user_preferences(module_id, db_name)
        
        # Merge with priority: baseline + user_prefs
        effective_settings = {**baseline, **user_prefs}
        
        return {
            "module_id": module_id,
            "settings": effective_settings,
            "baseline_count": len(baseline),
            "user_overrides_count": len(user_prefs)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(error_message(module_id=MODULE_ID, error_type="GET_SETTINGS_ERROR",
            details=f"Error getting settings for {module_id}: {str(e)}", location="get_module_settings()"))
        raise HTTPException(status_code=500, detail=create_error_response(
            module_id=MODULE_ID, code="INTERNAL_ERROR", message="Failed to get module settings"))

@router.put("/settings/{module_id}/{setting_key}", response_model=UserPreferenceResponse)
async def set_user_preference(module_id: str, setting_key: str, 
                            request: SetUserPreferenceRequest, service = Depends(get_module_service())):
    """Set a user preference override for a setting."""
    try:
        if not service or not service.initialized:
            raise HTTPException(status_code=503, detail=create_error_response(
                module_id=MODULE_ID, code="SERVICE_UNAVAILABLE", 
                message="Settings V2 service not available"))
        
        # Use configured database name
        db_name = service.get_configured_database_name()
        result = await service.set_user_preference(module_id, setting_key, request.value, db_name)
        
        if not result.success:
            raise HTTPException(status_code=400, detail=create_error_response(
                module_id=MODULE_ID, code="SET_PREFERENCE_FAILED", message=result.message))
        
        return {
            "success": True,
            "module_id": module_id,
            "setting_key": setting_key,
            "value": request.value,
            "action": result.data.get("action", "updated")
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(error_message(module_id=MODULE_ID, error_type="SET_PREFERENCE_ERROR",
            details=f"Error setting {module_id}.{setting_key}: {str(e)}", location="set_user_preference()"))
        raise HTTPException(status_code=500, detail=create_error_response(
            module_id=MODULE_ID, code="INTERNAL_ERROR", message="Failed to set user preference"))

@router.delete("/settings/{module_id}/{setting_key}", response_model=UserPreferenceResponse)
async def clear_user_preference(module_id: str, setting_key: str, service = Depends(get_module_service())):
    """Clear a user preference override (revert to baseline)."""
    try:
        if not service or not service.initialized:
            raise HTTPException(status_code=503, detail=create_error_response(
                module_id=MODULE_ID, code="SERVICE_UNAVAILABLE", 
                message="Settings V2 service not available"))
        
        # Use configured database name
        db_name = service.get_configured_database_name()
        result = await service.clear_user_preference(module_id, setting_key, db_name)
        
        if not result.success:
            raise HTTPException(status_code=400, detail=create_error_response(
                module_id=MODULE_ID, code="CLEAR_PREFERENCE_FAILED", message=result.message))
        
        return {
            "success": True,
            "module_id": module_id,
            "setting_key": setting_key,
            "cleared": result.data.get("cleared", False)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(error_message(module_id=MODULE_ID, error_type="CLEAR_PREFERENCE_ERROR",
            details=f"Error clearing {module_id}.{setting_key}: {str(e)}", location="clear_user_preference()"))
        raise HTTPException(status_code=500, detail=create_error_response(
            module_id=MODULE_ID, code="INTERNAL_ERROR", message="Failed to clear user preference"))

@router.get("/settings", response_model=AllSettingsResponse)
async def get_all_settings(service = Depends(get_module_service())):
    """Get all settings for all modules."""
    try:
        if not service or not service.initialized:
            raise HTTPException(status_code=503, detail=create_error_response(
                module_id=MODULE_ID, code="SERVICE_UNAVAILABLE", 
                message="Settings V2 service not available"))
        
        # Get all user preferences
        if service.user_prefs_db:
            # Use configured database name
            db_name = service.get_configured_database_name()
            prefs_result = await service.user_prefs_db.get_all_user_preferences(db_name)
            all_user_prefs = prefs_result.data if prefs_result.success else {}
        else:
            all_user_prefs = {}
        
        # Combine with baseline for all modules
        all_settings = {}
        for module_id, baseline in service.resolved_baseline.items():
            user_prefs = all_user_prefs.get(module_id, {})
            effective = {**baseline, **user_prefs}
            
            all_settings[module_id] = {
                "settings": effective,
                "baseline_count": len(baseline),
                "user_overrides_count": len(user_prefs)
            }
        
        return {
            "modules": all_settings,
            "total_modules": len(all_settings),
            "total_user_overrides": sum(len(prefs) for prefs in all_user_prefs.values())
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(error_message(module_id=MODULE_ID, error_type="GET_ALL_SETTINGS_ERROR",
            details=f"Error getting all settings: {str(e)}", location="get_all_settings()"))
        raise HTTPException(status_code=500, detail=create_error_response(
            module_id=MODULE_ID, code="INTERNAL_ERROR", message="Failed to get all settings"))